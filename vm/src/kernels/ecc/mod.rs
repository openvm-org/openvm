use std::sync::Arc;

use afs_primitives::bigint::utils::secp256k1_coord_prime;
use afs_stark_backend::{
    config::{StarkGenericConfig, Val},
    prover::types::AirProofInput,
    rap::AnyRap,
    Chip, ChipUsageGetter,
};
use p3_field::PrimeField32;

use super::adapters::native_vec_heap_adapter::NativeVecHeapAdapterChip;
use crate::{
    arch::{ExecutionState, InstructionExecutor, Result, VmChipWrapper},
    intrinsics::{
        ecc::sw::{ec_add_ne_expr, ec_double_expr},
        field_expression::FieldExpressionCoreChip,
    },
    system::{memory::MemoryControllerRef, program::Instruction},
};

pub struct KernelEcAddNeChip<F: PrimeField32, const NUM_LIMBS: usize>(
    VmChipWrapper<
        F,
        NativeVecHeapAdapterChip<F, 2, 2, 2, NUM_LIMBS, NUM_LIMBS>,
        FieldExpressionCoreChip,
    >,
);

impl<F: PrimeField32, const NUM_LIMBS: usize> KernelEcAddNeChip<F, NUM_LIMBS> {
    pub fn new(
        adapter: NativeVecHeapAdapterChip<F, 2, 2, 2, NUM_LIMBS, NUM_LIMBS>,
        memory_controller: MemoryControllerRef<F>,
        limb_bits: usize,
        offset: usize,
    ) -> Self {
        let expr = ec_add_ne_expr(
            secp256k1_coord_prime(),
            NUM_LIMBS,
            limb_bits,
            memory_controller.borrow().range_checker.bus(),
        );
        let core = FieldExpressionCoreChip::new(
            expr,
            offset,
            memory_controller.borrow().range_checker.clone(),
            "EcAddNe",
        );
        Self(VmChipWrapper::new(adapter, core, memory_controller))
    }
}

pub struct KernelEcDoubleChip<F: PrimeField32, const NUM_LIMBS: usize>(
    VmChipWrapper<
        F,
        NativeVecHeapAdapterChip<F, 1, 2, 2, NUM_LIMBS, NUM_LIMBS>,
        FieldExpressionCoreChip,
    >,
);

impl<F: PrimeField32, const NUM_LIMBS: usize> KernelEcDoubleChip<F, NUM_LIMBS> {
    pub fn new(
        adapter: NativeVecHeapAdapterChip<F, 1, 2, 2, NUM_LIMBS, NUM_LIMBS>,
        memory_controller: MemoryControllerRef<F>,
        limb_bits: usize,
        offset: usize,
    ) -> Self {
        let expr = ec_double_expr(
            secp256k1_coord_prime(),
            NUM_LIMBS,
            limb_bits,
            memory_controller.borrow().range_checker.bus(),
        );
        let core = FieldExpressionCoreChip::new(
            expr,
            offset,
            memory_controller.borrow().range_checker.clone(),
            "EcDouble",
        );
        Self(VmChipWrapper::new(adapter, core, memory_controller))
    }
}

// TODO: below can be generated by the macro.
impl<F: PrimeField32, const NUM_LIMBS: usize> InstructionExecutor<F>
    for KernelEcAddNeChip<F, NUM_LIMBS>
{
    fn execute(
        &mut self,
        instruction: Instruction<F>,
        from_state: ExecutionState<u32>,
    ) -> Result<ExecutionState<u32>> {
        self.0.execute(instruction, from_state)
    }

    fn get_opcode_name(&self, opcode: usize) -> String {
        self.0.get_opcode_name(opcode)
    }
}

impl<F: PrimeField32, const NUM_LIMBS: usize> ChipUsageGetter for KernelEcAddNeChip<F, NUM_LIMBS> {
    fn air_name(&self) -> String {
        self.0.air_name()
    }

    fn current_trace_height(&self) -> usize {
        self.0.current_trace_height()
    }

    fn trace_width(&self) -> usize {
        self.0.trace_width()
    }
}

impl<const NUM_LIMBS: usize, SC> Chip<SC> for KernelEcAddNeChip<Val<SC>, NUM_LIMBS>
where
    SC: StarkGenericConfig,
    Val<SC>: PrimeField32,
{
    fn air(&self) -> Arc<dyn AnyRap<SC>> {
        self.0.air()
    }

    fn generate_air_proof_input(self) -> AirProofInput<SC> {
        self.0.generate_air_proof_input()
    }
}

impl<F: PrimeField32, const NUM_LIMBS: usize> InstructionExecutor<F>
    for KernelEcDoubleChip<F, NUM_LIMBS>
{
    fn execute(
        &mut self,
        instruction: Instruction<F>,
        from_state: ExecutionState<u32>,
    ) -> Result<ExecutionState<u32>> {
        self.0.execute(instruction, from_state)
    }

    fn get_opcode_name(&self, opcode: usize) -> String {
        self.0.get_opcode_name(opcode)
    }
}

impl<F: PrimeField32, const NUM_LIMBS: usize> ChipUsageGetter for KernelEcDoubleChip<F, NUM_LIMBS> {
    fn air_name(&self) -> String {
        self.0.air_name()
    }

    fn current_trace_height(&self) -> usize {
        self.0.current_trace_height()
    }

    fn trace_width(&self) -> usize {
        self.0.trace_width()
    }
}

impl<const NUM_LIMBS: usize, SC> Chip<SC> for KernelEcDoubleChip<Val<SC>, NUM_LIMBS>
where
    SC: StarkGenericConfig,
    Val<SC>: PrimeField32,
{
    fn air(&self) -> Arc<dyn AnyRap<SC>> {
        self.0.air()
    }

    fn generate_air_proof_input(self) -> AirProofInput<SC> {
        self.0.generate_air_proof_input()
    }
}
