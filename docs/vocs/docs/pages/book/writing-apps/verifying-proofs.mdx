# Verifying Proofs

To verify a proof generated by OpenVM, you can use the following CLI command:

```bash
cargo openvm verify [app | stark | evm]
```

## Verifying Application Proofs

Verifying a proof at the application level requires both the proof and application verifying key.

```bash
cargo openvm verify app
    --app-vk <path_to_app_vk>
    --proof <path_to_proof>
```

Options `--manifest-path`, `--target-dir` are also available to `verify`. If you omit `--app_vk` the command will search for the verifying key at `${target_dir}/openvm/app.vk`.

If you omit `--proof`, the command will search the working directory for files with the `.app.proof` extension. In this 
case, we expect to find a single proof, and `verify` will fail otherwise.

## Verifying STARK Proofs

To verify a STARK proof, you can run the following command:

```bash
cargo openvm verify stark --proof <path_to_proof>
```

If you omit `--proof`, the command will search the working directory for files with the `.stark.proof` extension. In this 
case, we expect to find a single proof, and `verify` will fail otherwise.

The command defaults to reading a JSON file containing `app_exe_commit` and `app_vm_commit` fields at 
`${target_dir}/openvm/release/${target}.commit.json`. To override this, you can use the `--app-commit` option
to specify a path to a JSON file generated by the `cargo openvm commit`
CLI command as described [here](book/writing-apps/compiling-a-program#generating-commitments-for-guest-programs). 

:::info
The `cargo openvm verify stark` command implicitly reads the STARK aggregation verification key generated by the `cargo openvm setup` command
from `~/.openvm/agg_stark.vk`. 
:::

## Verifying EVM Proofs

To verify an EVM proof, you can run the following command or call the `IOpenVmHalo2Verifier.verify()` function in the [OpenVM Solidity SDK](/book/writing-apps/solidity-sdk).

```bash
cargo openvm verify evm --proof <path_to_proof>
```

If you omit `--proof`, the command will search the working directory for files with the `.evm.proof` extension. In this 
case, we expect to find a single proof, and `verify` will fail otherwise.

### EVM Proof: JSON Format

The EVM proof is written as a JSON of the following format:

```json [[...].evm.proof]
{
  "app_exe_commit": "0x..",
  "app_vm_commit": "0x..",
  "user_public_values": "0x..",
  "proof_data": {
    "accumulator": "0x..",
    "proof": "0x.."
  },
}
```

where each field is a hex string. We explain what each field represents:

- `app_exe_commit`: `32` bytes for the commitment of the app executable.
- `app_vm_commit`: `32` bytes for the commitment of the app VM configuration.
- `user_public_values`: concatenation of 32 byte chunks for user public values. The number of user public values is a configuration parameter.
- `accumulator`: `12 * 32` bytes representing the KZG accumulator of the proof, where the proof is from a SNARK using the KZG commitment scheme.
- `proof`: The rest of the proof required by the SNARK as a hex string of `43 * 32` bytes.

### EVM Proof: Calldata Format

The `cargo openvm verify evm` command reads the EVM proof from JSON file and then simulates the call to the verifier contract using [Revm](https://github.com/bluealloy/revm/tree/main). This function should only be used for testing and development purposes but not for production.

To verify the EVM proof in an EVM execution environment, the entries of the JSON can be passed as function arguments for the `verify` function, where the `proofData` argument is constructed by `proofData = abi.encodePacked(accumulator, proof)`.
