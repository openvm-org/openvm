# Using the SDK

While the CLI provides a convenient way to build, prove, and verify programs, you may want more fine-grained control over the process. The OpenVM Rust SDK allows you to customize various aspects of the workflow programmatically.

For more information on the basic CLI flow, see [Overview of Basic Usage](/book/writing-apps/overview). Writing a guest program is the same as in the CLI.

## Imports and Setup

If you have a guest program and would like to try running the **host program** specified in the next section, you can do so by adding the following imports and setup at the top of the file. You may need to modify the imports and/or the `SomeStruct` struct to match your program.

```rust
// [!include ~/snippets/examples_sdk/sdk_stark.rs:dependencies]
```

## Building and Transpiling a Program

The SDK provides lower-level control over the building and transpiling process.

```rust
// [!include ~/snippets/examples_sdk/sdk_stark.rs:build]
// [!include ~/snippets/examples_sdk/sdk_stark.rs:read_elf]

// [!include ~/snippets/examples_sdk/sdk_stark.rs:transpilation]
```

### Customizing the VM Configuration

To use a custom VM configuration, you can construct your own `GenericSdk` object which includes the
extensions and system configuration your VM will use. To do this, you can use the `SdkVmConfig::builder()`
 method and set the desired extensions and system configuration as in the example below.

```rust
    let vm_config = SdkVmConfig::builder()
        .system(Default::default())
        .rv32i(Default::default())
        .rv32m(Default::default())
        .io(Default::default())
        .build()
        .optimize();
    let sdk = Sdk::new(
        AppConfig::new(FriParameters::standard_fast(), vm_config)
    )?;
```

The following convenience methods are also available to construct a `GenericSdk` object:

- `Sdk::riscv32()` returns a `GenericSdk` supporting the RV32IM extension.
- `Sdk::standard()` returns a `GenericSdk` supporting all default OpenVM extensions, including RV32IM.
- `Sdk::new(Sdk::from_toml(openvm.toml))` returns a `GenericSdk` from a custom OpenVM configuration specified in an `openvm.toml` file.

:::info
When using Rust to write the guest program, the VM system configuration should keep the default value `pointer_max_bits = 29` to match the hardcoded memory limit of the memory allocator. Otherwise, the guest program may fail due to out of bounds memory access in the VM.
:::

## Running a Program

To run your program and see the public value output, you can do the following:

```rust
// [!include ~/snippets/examples_sdk/sdk_stark.rs:execution]
```

### Using `StdIn`

The `StdIn` struct allows you to format any serializable type into a VM-readable format by passing in a reference to your struct into `StdIn::write` as above. You also have the option to pass in a `&[u8]` into `StdIn::write_bytes`, or a `&[F]` into `StdIn::write_field` where `F` is the `openvm_stark_sdk::p3_baby_bear::BabyBear` field type.

:::info
**Generating CLI Bytes**
To get the VM byte representation of a serializable struct `data` (i.e. for use in the CLI), you can print out the result of `openvm::serde::to_vec(data).unwrap()` in a Rust host program.
:::

## Generating and Verifying Proofs

OpenVM supports generating three types of proofs. The sections below describe how to generate and verify each type of proof.

- [App Proof](#app-proof): Generates STARK proof(s) of the guest program
- [STARK Proof](#stark-proof): Generates a STARK proof that can be posted on-chain
- [EVM Proof](#evm-proof): Generates a halo2 proof that can be posted on-chain

## App Proof

### Generating App Proofs

After building and transpiling a program, you can then generate a proof. To do so, you need to commit your `VmExe`, generate an `AppProvingKey`, format your input into `StdIn`, and then generate a proof.

```rust
// [!include ~/snippets/examples_sdk/sdk_stark.rs:proof_generation]
```

For large guest programs, the program will be proved in multiple continuation segments and the returned `proof: ContinuationVmProof` object consists of multiple STARK proofs, one for each segment.

### Verifying App Proofs

After generating a proof, you can verify it. To do so, you need your verifying key (which you can get from your `AppProvingKey`) and the output of your `generate_app_proof` call.

```rust
// [!include ~/snippets/examples_sdk/sdk_stark.rs:verification]
```

## STARK Proof

### Setup

To generate a STARK proof, you first need to generate proving and verification keys for STARK aggregation using the following command:

```bash
cargo openvm setup
```

### STARK Proof Generation and Verification

You can now run the aggregation keygen, proof, and verification functions for the STARK proof.

```rust 
// [!include ~/snippets/examples_sdk/sdk_stark.rs:proof_generation]
```

Once the proof is generated, you can verify it using the SDK as follows:

```rust
// [!include ~/snippets/examples_sdk/sdk_stark.rs:verification]
```

## EVM Proof

### Setup

To generate an EVM proof, you'll first need to ensure that you have followed the [CLI installation steps](/book/getting-started/install)
to generate proving and verification keys for EVM proving.

```bash
cargo openvm setup --evm
```

:::warning
`cargo openvm setup --evm` requires a large amount of computation and memory (~70 GB).
:::

<details>
<summary>Also note that there are additional dependencies for the EVM Proof flow. Click here to view.</summary>

```rust
// [!include ~/snippets/examples_sdk/sdk_evm.rs:dependencies]
```

</details>

### EVM Proof Generation and Verification

You can now run the aggregation keygen, proof, and verification functions for the EVM proof.

**Note**: you **do not** need to generate the app proof with the `generate_app_proof` function, as the EVM proof function will handle this automatically.

```rust
// [!include ~/snippets/examples_sdk/sdk_evm.rs:evm_verification]
```

:::warning
The halo2 aggregation proving key `agg_halo2.pk` used in the above example is large. Avoid cloning it if possible.
:::

Note that `DEFAULT_PARAMS_DIR` is the directory where Halo2 parameters are stored by the `cargo openvm setup --evm` CLI command. For more information on the setup process, see the `EVM Level` section of the [verify](/book/writing-apps/verifying-proofs) doc.
