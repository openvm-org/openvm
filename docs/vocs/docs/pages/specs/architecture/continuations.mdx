# Continuations Specification

## Introduction

### Overview

An app execution may require arbitrarily many steps, but each proof covers a bounded number of steps. OpenVM thus splits execution into **segments** and produces one proof per segment. **Continuation** is the process of recursively aggregating segment proofs into (usually) a single proof by:

1. Verifying child proofs from adjacent segments
2. Verifying public value consistency between adjacent child proofs
3. Outputting a proof attesting to 1 and 2

This forms an **aggregation tree** with multiple **layers**, where each layer aggregates child proofs from the layer below. There are seven **layer types**:

| Layer | Description |
|-------|-------------|
| app | Executes a program on the VM, then produces one `Proof` per segment and a Merkle proof of user public values' presence in the final memory state |
| leaf | Aggregates up to $N_\mathsf{leaf}$ app segment `Proof`s into a single `Proof` |
| internal-for-leaf | Aggregates up to $N_\mathsf{internal}$ leaf `Proof`s into a single `Proof` |
| internal-recursive | Aggregates up to $N_\mathsf{internal}$ internal-for-leaf `Proof`s, or up to $N_\mathsf{internal}$ internal-recursive `Proof`s. Note $N_\mathsf{internal}$ is the same at all internal layers. |
| compression | Wraps a single internal-recursive `Proof`, computing the [DAG commit in-circuit](#constraint-dag-and-cached-traces) to reduce final `Proof` size (no cached trace) |
| root | Wraps a single internal-recursive `Proof` and verifies user public values exist in final memory |
| static | Re-encodes root `Proof` into a fixed, constant-sized format for on-chain verification |

The first six types each correspond to a unique STARK-based circuit. The **static** layer is handled separately — it re-encodes a root `Proof` for on-chain verification. Because this encoding must be constant-sized, the root `Proof` size must also be fixed.

### Circuit and Prover Definitions

A **circuit** is a set of AIRs that collectively constrain one or more trace matrices and expose a fixed set of public values. A **subcircuit** is a subset of a circuit's AIRs.

A **prover** is a struct that generates a proof for a specific circuit given appropriate inputs. We distinguish:

- **Basic provers** — generate a single aggregated `Proof` from child `Proof`s. Each basic prover corresponds to a specific aggregation subcircuit (see [Layer Architecture](#layer-architecture) for more information).
- **SDK provers** — orchestrate basic provers to produce client-facing proof formats (`ContinuationVmProof`, `NonRootStarkProof`, `EvmProof`) or their intermediate forms.

## Client-Facing Proofs

There are three **client-facing proof** types:

| Type | Struct | Description |
|------|--------|-------------|
| App proof | `ContinuationVmProof` | Non-aggregated segment `Proof`s plus the user public values Merkle proof |
| STARK proof | `NonRootStarkProof` | A single aggregated `Proof` plus the user public values Merkle proof |
| EVM proof | `EvmProof` | A single, constant-sized aggregated `Proof` formatted for verification by a fixed on-chain verifier |

### Aggregation Pipelines

Each client-facing proof type requires a specific aggregation pipeline:

| Proof Type | Pipeline |
|------------|----------|
| App | app (no aggregation) |
| STARK | app → leaf → internal-for-leaf → internal-recursive (repeated at least until one `Proof` remains) → compression (optional) |
| EVM | app → leaf → internal-for-leaf → internal-recursive (repeated at least until one `Proof` remains) → root → static |

![STARK Proof Diagram](/stark-proof-diagram.png)

*Diagram of a potential STARK proof aggregation tree with 2:1 max leaf aggregation and 3:1 max internal aggregation. In practice, there often should be several 1:1 internal-recursive layers before the compression layer if proof size is a concern.*

:::note
Wrapping an internal-recursive `Proof` 1:1 in another internal-recursive layer will typically reduce its size. We use this in:
- **STARK proving** — some applications (e.g. real time proving) require a maximum proof size
- **EVM proving** — the root `Proof` size must be constant, and thus the internal-recursive child `Proof` must be smaller than some maximum
:::

### SDK Provers

For convenience the SDK provides several **SDK provers**, which orchestrate basic provers to produce client-facing proof formats. Most wrap disjoint aggregation pipeline sections; we informally denote these "component SDK provers".

| Component SDK Prover | Aggregation Pipeline Section | Input | Output |
|-------|-----------------|------------------|-------|
| `AppProver` | app | Executable and `StdIn` input | `ContinuationVmProof` (i.e. app proof) |
| `AggProver` | leaf → internal-for-leaf → internal-recursive (repeated at least until one `Proof` remains) | `ContinuationVmProof` | `NonRootStarkProof` (i.e. STARK proof) |
| `CompressionSdkProver` | compression | `NonRootStarkProof` | `NonRootStarkProof` |
| `RootSdkProver` | root | `NonRootStarkProof` | `Proof` (EVM input) |
| `StaticProver` | static | `Proof` | `EvmProof` (EVM proof) |

`StarkProver` and `EvmProver` use these component SDK provers to encapsulate end-to-end STARK and EVM proving.

| E2E SDK Prover | Component Prover Pipeline | Input | Output |
|-------|-----------------|-------|-------|
| `StarkProver` | `AppProver` → `AggProver` → `CompressionSdkProver` (optionally) | Executable and `StdIn` input | `NonRootStarkProof` |
| `EvmProver` | `AppProver` → `AggProver` → `RootSdkProver` → `StaticProver` | Executable and `StdIn` input | `EvmProof` |

## Layer Architecture

Every non-app STARK-based layer has a circuit composed of exactly two subcircuits:

- A **verifier subcircuit** — verifies child proofs individually
- An **aggregation subcircuit** — enforces public value consistency across child proofs and exposes public values for the next layer

Different layers may share the same verifier subcircuit or the same aggregation subcircuit, but each layer's circuit is a unique pairing.

| Layer | Verifier Subcircuit | Aggregation Subcircuit |
|-------|---------------------|------------------------|
| app | (VM execution) | (none) |
| leaf | [leaf](#constraint-dag-and-cached-traces) | [nonroot](#nonroot-aggregation-subcircuit) |
| internal-for-leaf | [internal-for-leaf](#constraint-dag-and-cached-traces) | [nonroot](#nonroot-aggregation-subcircuit) |
| internal-recursive | [internal-recursive](#constraint-dag-and-cached-traces) | [nonroot](#nonroot-aggregation-subcircuit) |
| compression | [compression](#constraint-dag-and-cached-traces) | [compression](#compression-aggregation-subcircuit) |
| root | [internal-recursive](#constraint-dag-and-cached-traces) | [root](#root-aggregation-subcircuit) |

Note that leaf, internal-for-leaf, and internal-recursive all share the nonroot aggregation subcircuit and therefore have the same public value layout. Root reuses the internal-recursive verifier subcircuit but pairs it with a different aggregation subcircuit.

### Verifying Key Convergence

Each verifier subcircuit is parameterized by the child proof's verifying key (`child_vk`). Because the verifier subcircuit depends on `child_vk`, each layer initially has a different circuit:

- leaf circuit is derived from `app_vk`
- internal-for-leaf circuit is derived from `leaf_vk`
- internal-recursive circuit is derived from `internal_for_leaf_vk`

However, the system is designed so that the circuit **converges** at the internal-recursive layer. This means:

1. The verifier subcircuit derived from `internal_recursive_vk` is identical to the internal-recursive verifier subcircuit itself
2. An internal-recursive `Proof` can be used as a child proof for another internal-recursive proof
3. For fixed internal system parameters, the internal-recursive circuit is the same for any `app_vk`

This convergence property enables unbounded recursive aggregation.

## Verifier Subcircuits

### Shared Structure

All verifier subcircuits are semantically equivalent — each contains the same subset of AIRs that individually verify child proofs. However, the actual circuit constraints and parameters are derived from:

1. The child proof's verifying key (`child_vk`)
2. The maximum number of child `Proof`s this subcircuit can verify ($N_\mathsf{leaf}$ for leaf, $N_\mathsf{internal}$ for internal, and 1 for other layers)
3. A boolean `has_cached` flag indicating whether a cached trace is present

Because of the dependency on `child_vk`, different layers have different verifier subcircuits until [convergence at internal-recursive](#verifying-key-convergence).

### Constraint DAG and Cached Traces

A verifier subcircuit must verify that a child proof satisfies the constraints defined by `child_vk`. These constraints are encoded as a **constraint DAG**, where each node represents a symbolic expression over trace values. This DAG includes interaction constraints.

To avoid recomputing the DAG in-circuit, most verifier subcircuits use a **cached trace**: before proving, the DAG is serialized per-node into a cached trace, committed via SWIRL's stacked PCS, and the commitment is exposed as a public value. This commitment is called a `*_dag_commit`:

| Public Value | Commits to |
|--------------|------------|
| `app_dag_commit` | `app_vk` constraint DAG |
| `leaf_dag_commit` | `leaf_vk` constraint DAG |
| `internal_for_leaf_dag_commit` | `internal_for_leaf_vk` constraint DAG |
| `internal_recursive_dag_commit` | `internal_recursive_vk` constraint DAG |

Each `*_dag_commit` is checked for consistency by the aggregation subcircuit and/or the final client-facing verifier.

:::note
System parameters and per-AIR `is_required` flags are not included in `*_dag_commit`; they are fixed by the parent circuit.
:::

| Subcircuit Layer | `child_vk` | Max child proofs | Cached trace |
|------------|------------|------------------|--------------|
| leaf | `app_vk` | $N_\mathsf{leaf}$ | yes |
| internal-for-leaf | `leaf_vk` | $N_\mathsf{internal}$ | yes |
| internal-recursive | `internal_for_leaf_vk` | $N_\mathsf{internal}$ | yes |
| compression | `internal_recursive_vk` | 1 | no |

As described in [Verifying Key Convergence](#verifying-key-convergence), the verifier subcircuit derived from `internal_recursive_vk` is identical to internal-recursive, enabling unbounded recursion. The internal-recursive verifier subcircuit can thus verify its own `Proof`s.

The compression verifier subcircuit does **not** use a cached trace. Instead, the constraint DAG columns are included in the main trace of `SymbolicExpressionAir` and hashed in-circuit by its DAG commit sub-AIR (`DagCommitSubAir`). This computes a running hash over the DAG columns and exposes the result as `compression_commit`, which is checked for consistency by the STARK verifier.

:::note
`compression_commit` is an alternative commitment to the internal-recursive constraint DAG, computed in-circuit rather than from a cached trace.
:::

Because compression lacks a cached trace, it is only used as the final layer before outputting a STARK proof.

## Aggregation Subcircuits

There are 3 aggregation subcircuit types: **nonroot**, **compression**, and **root**. Each type has an associated basic prover.

### App Public Values and Shared Constraints

App public values are the public values exposed by the app layer. They are propagated through all aggregation layers.

- `initial_pc: F` — starting PC value of the program/segment
- `final_pc: F` — final PC value of the program/segment
- `exit_code: F` — exit code of the program/segment
- `is_terminate: F` — boolean flag indicating whether this segment terminated the program
- `initial_root: Digest` — Merkle root of the initial memory state
- `final_root: Digest` — Merkle root of the final memory state

All aggregation subcircuits enforce **segment adjacency** constraints on the app public values. Given several adjacent segments, the aggregation subcircuit constrains that:

1. The `final_pc` and `final_root` of each non-terminal segment equal the `initial_pc` and `initial_root` of the segment immediately following it
2. Non-terminal segments have `is_terminate == 0` and `exit_code == ExitCode::SUSPEND`
3. The terminal segment has `is_terminate == 1` and `exit_code == ExitCode::Success`

The aggregation subcircuit also **exposes public values** necessary for either further recursive aggregation or final proof verification.

:::note
Layers with a single child `Proof` practically only need to constrain 3.
:::

### Nonroot Aggregation Subcircuit

The nonroot subcircuit takes up to $N$ child `Proof`s and does **not** constrain the user public values' presence in memory. Its output `Proof` is meant to either be recursively aggregated or used as the `Proof` component in a `NonRootStarkProof`.

#### Public Values

Public values are processed by `VerifierPvsAir`. The nonroot subcircuit re-exposes the app public values (excluding `user_public_values`) and adds the following **verifier-specific public values**, which are common over all nonroot layers:

- **Program Commit**
    - `program_commit: Digest` — cached trace commit of the app circuit's `ProgramAir`
- **Aggregation Public Values**
    - `internal_flag: F` — ternary flag indicating which verifier subcircuit this proof is for:
      - `0` for leaf
      - `1` for internal-for-leaf
      - `2` for internal-recursive (or compression)
    - `app_dag_commit: Digest` — cached trace commit of the leaf verifier subcircuit's `SymbolicExpressionAir`, derived from `app_vk`
    - `leaf_dag_commit: Digest` — cached trace commit of the internal-for-leaf verifier subcircuit's `SymbolicExpressionAir`, derived from `leaf_vk`
    - `internal_for_leaf_dag_commit: Digest` — cached trace commit of the first (index 0) internal-recursive layer verifier subcircuit's `SymbolicExpressionAir`, derived from `internal_for_leaf_vk`
- **Internal Recursion-Related Public Values**
    - `recursion_flag: F` — ternary flag indicating which internal-recursive layer this proof is for:
      - `0` for non-internal-recursive layers
      - `1` for the first (index 0) internal-recursive layer
      - `2` for subsequent internal-recursive layers
    - `internal_recursive_dag_commit: Digest` — cached trace commit of each subsequent (index > 0) internal-recursive layer verifier subcircuit's `SymbolicExpressionAir`, derived from `internal_recursive_vk`

The `program_commit` should be set at every layer, but the flags and `*_dag_commits` should be set according to which layer we are currently proving for. Unset `*_dag_commits` are filled with 0s.

| Layer | `internal_flag` | `recursion_flag` | `app` | `leaf` | `internal_for_leaf` | `internal_recursive` |
|-------|-----------------|------------------|-------|--------|---------------------|----------------------|
| leaf | 0 | 0 | set | unset | unset | unset |
| internal-for-leaf | 1 | 0 | set | set | unset | unset |
| internal-recursive (layer 0) | 2 | 1 | set | set | set | unset |
| internal-recursive (layer 1+) | 2 | 2 | set | set | set | set |

#### Constraints

`VerifierPvsAir` constrains that:

- App segment proofs do not have nonroot subcircuit-specific public values
- Non-app child proofs within a layer have the **same** verifier-specific public values
- Child proof verifier-specific public values are set according to the table above
- Output proof verifier-specific public values match the child proofs':
  - Flags are incremented properly
  - The next unset `*_dag_commit` is set (if any remain unset)
  - Previously defined `*_dag_commit`s match between child and output

### Compression Aggregation Subcircuit

The compression subcircuit takes a single internal-recursive child `Proof` and does **not** constrain the user public values' presence in memory. Its output `Proof` is meant to be used as the `Proof` component in a `NonRootStarkProof`.

The compression subcircuit has the same AIR set as nonroot, but with `SymbolicExpressionAir` configured without a cached trace and with its DAG commit sub-AIR enabled. This computes and exposes `compression_commit` — an [alternative commitment to the `internal_recursive_vk` constraint DAG](#constraint-dag-and-cached-traces).

#### Public Values

Same as nonroot, with the addition of:

- `compression_commit: Digest` — in-circuit generated commit of the internal-recursive constraint DAG

Flags and `*_dag_commit`s should be set as they are beyond the 0th internal-recursive layer.

### Root Aggregation Subcircuit

The root subcircuit takes a single internal-recursive child `Proof` and **does** constrain the user public values' presence in memory. Its output `Proof` is meant to be the static layer input.

#### Public Values

The root subcircuit exposes a new set of public values for the static verifier. Segment adjacency public values are no longer needed since adjacency has already been enforced.

- `user_public_values: Vec<F>` — user-defined public values stored in the public values address space during app execution
- `app_exe_commit: Digest` — hashed combination of:
  - The app-level `ProgramAir` cached trace commit
  - The Merkle root of the starting app memory state (`initial_root`)
  - The initial app program counter (`initial_pc`)
- `app_dag_commit: Digest` — cached trace commit of the leaf verifier subcircuit's `SymbolicExpressionAir`, derived from `app_vk`
- `leaf_dag_commit: Digest` — cached trace commit of the internal-for-leaf verifier subcircuit's `SymbolicExpressionAir`, derived from `leaf_vk`
- `internal_for_leaf_dag_commit: Digest` — cached trace commit of the first (index 0) internal-recursive layer verifier subcircuit's `SymbolicExpressionAir`, derived from `internal_for_leaf_vk`

#### Constraints

The root subcircuit constrains the child proof's public values:

- `is_terminate == 1` and `exit_code == ExitCode::Success` (successful app termination)
- `internal_flag == 2` and `recursion_flag` is `1` or `2` (child is internal-recursive)
- `SymbolicExpressionAir`'s cached commit equals `internal_recursive_dag_commit`
- `internal_recursive_dag_commit` matches a pre-generated constant commit

The root subcircuit also constrains its own public values:

- `user_public_values` were in the final memory state's public values address space, constrained by:
    - Computing the Merkle root of `user_public_values`, denoted `user_pvs_commit`
    - Constraining that a Merkle proof (where the path to the root depends on the `MemoryDimensions`) exists between `user_pvs_commit` and `final_root`
- `app_exe_commit` is computed as specified above
- `app_dag_commit`, `leaf_dag_commit`, and `internal_for_leaf_dag_commit` equal the child proof's values
