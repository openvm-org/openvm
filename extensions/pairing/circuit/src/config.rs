use std::result::Result;

use openvm_algebra_circuit::{
    AlgebraCpuProverExt, Fp2Extension, Fp2ExtensionExecutor, Rv32ModularConfig,
    Rv32ModularConfigExecutor, Rv32ModularCpuBuilder,
};
use openvm_circuit::{
    arch::{
        AirInventory, ChipInventoryError, InitFileGenerator, MatrixRecordArena, SystemConfig,
        VmBuilder, VmChipComplex, VmProverExtension,
    },
    system::SystemChipInventory,
};
use openvm_circuit_derive::VmConfig;
use openvm_ecc_circuit::{EccCpuProverExt, WeierstrassExtension, WeierstrassExtensionExecutor};
use openvm_stark_backend::{
    config::{StarkGenericConfig, Val},
    engine::StarkEngine,
    p3_field::PrimeField32,
    prover::cpu::{CpuBackend, CpuDevice},
};
use serde::{Deserialize, Serialize};

use super::*;

#[derive(Clone, Debug, VmConfig, Serialize, Deserialize)]
pub struct Rv32PairingConfig {
    #[config(generics = true)]
    pub modular: Rv32ModularConfig,
    #[extension]
    pub fp2: Fp2Extension,
    #[extension]
    pub weierstrass: WeierstrassExtension,
    #[extension(generics = true)]
    pub pairing: PairingExtension,
}

impl Rv32PairingConfig {
    pub fn new(curves: Vec<PairingCurve>, complex_struct_names: Vec<String>) -> Self {
        let modulus_primes: Vec<_> = curves
            .iter()
            .map(|c| c.curve_config().modulus.clone())
            .collect();
        let mut modulus_and_scalar_primes = modulus_primes.clone();
        modulus_and_scalar_primes.extend(curves.iter().map(|c| c.curve_config().scalar.clone()));
        Self {
            modular: Rv32ModularConfig::new(modulus_and_scalar_primes),
            fp2: Fp2Extension::new(
                complex_struct_names
                    .into_iter()
                    .zip(modulus_primes)
                    .collect(),
            ),
            weierstrass: WeierstrassExtension::new(
                curves.iter().map(|c| c.curve_config()).collect(),
            ),
            pairing: PairingExtension::new(curves),
        }
    }
}

impl InitFileGenerator for Rv32PairingConfig {
    fn generate_init_file_contents(&self) -> Option<String> {
        Some(format!(
            "// This file is automatically generated by cargo openvm. Do not rename or edit.\n{}\n{}\n{}\n",
            self.modular.modular.generate_moduli_init(),
            self.fp2.generate_complex_init(&self.modular.modular),
            self.weierstrass.generate_sw_init()
        ))
    }
}

#[derive(Clone)]
pub struct Rv32PairingCpuBuilder;

impl<E, SC> VmBuilder<E> for Rv32PairingCpuBuilder
where
    SC: StarkGenericConfig,
    E: StarkEngine<SC = SC, PB = CpuBackend<SC>, PD = CpuDevice<SC>>,
    Val<SC>: PrimeField32,
{
    type VmConfig = Rv32PairingConfig;
    type SystemChipInventory = SystemChipInventory<SC>;
    type RecordArena = MatrixRecordArena<Val<SC>>;

    fn create_chip_complex(
        &self,
        config: &Rv32PairingConfig,
        circuit: AirInventory<SC>,
    ) -> Result<
        VmChipComplex<SC, Self::RecordArena, E::PB, Self::SystemChipInventory>,
        ChipInventoryError,
    > {
        let mut chip_complex =
            VmBuilder::<E>::create_chip_complex(&Rv32ModularCpuBuilder, &config.modular, circuit)?;
        let inventory = &mut chip_complex.inventory;
        VmProverExtension::<E, _, _>::extend_prover(&AlgebraCpuProverExt, &config.fp2, inventory)?;
        VmProverExtension::<E, _, _>::extend_prover(
            &EccCpuProverExt,
            &config.weierstrass,
            inventory,
        )?;
        VmProverExtension::<E, _, _>::extend_prover(&PairingProverExt, &config.pairing, inventory)?;
        Ok(chip_complex)
    }
}
