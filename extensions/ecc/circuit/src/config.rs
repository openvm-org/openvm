use std::result::Result;

use openvm_algebra_circuit::{Rv32ModularConfig, Rv32ModularConfigExecutor, Rv32ModularCpuBuilder};
use openvm_circuit::{
    arch::{
        AirInventory, ChipInventoryError, InitFileGenerator, MatrixRecordArena, SystemConfig,
        VmBuilder, VmChipComplex, VmProverExtension,
    },
    system::SystemChipInventory,
};
use openvm_circuit_derive::VmConfig;
use openvm_stark_backend::{
    config::{StarkGenericConfig, Val},
    engine::StarkEngine,
    p3_field::PrimeField32,
    prover::cpu::{CpuBackend, CpuDevice},
};
use serde::{Deserialize, Serialize};

use super::*;

#[derive(Clone, Debug, VmConfig, Serialize, Deserialize)]
pub struct Rv32EccConfig {
    #[config(generics = true)]
    pub modular: Rv32ModularConfig,
    #[extension]
    pub ecc: EccExtension,
}

impl Rv32EccConfig {
    pub fn new(
        sw_curves: Vec<CurveConfig<SwCurveCoeffs>>,
        te_curves: Vec<CurveConfig<TeCurveCoeffs>>,
    ) -> Self {
        let sw_primes: Vec<_> = sw_curves
            .iter()
            .flat_map(|c| [c.modulus.clone(), c.scalar.clone()])
            .collect();
        let te_primes: Vec<_> = te_curves
            .iter()
            .flat_map(|c| [c.modulus.clone(), c.scalar.clone()])
            .collect();
        let primes = sw_primes.into_iter().chain(te_primes).collect();
        Self {
            modular: Rv32ModularConfig::new(primes),
            ecc: EccExtension::new(sw_curves, te_curves),
        }
    }
}

impl InitFileGenerator for Rv32EccConfig {
    fn generate_init_file_contents(&self) -> Option<String> {
        Some(format!(
            "// This file is automatically generated by cargo openvm. Do not rename or edit.\n{}\n{}\n",
            self.modular.modular.generate_moduli_init(),
            self.ecc.generate_ecc_init()
        ))
    }
}

#[derive(Clone)]
pub struct Rv32EccCpuBuilder;

impl<E, SC> VmBuilder<E> for Rv32EccCpuBuilder
where
    SC: StarkGenericConfig,
    E: StarkEngine<SC = SC, PB = CpuBackend<SC>, PD = CpuDevice<SC>>,
    Val<SC>: PrimeField32,
{
    type VmConfig = Rv32EccConfig;
    type SystemChipInventory = SystemChipInventory<SC>;
    type RecordArena = MatrixRecordArena<Val<SC>>;

    fn create_chip_complex(
        &self,
        config: &Self::VmConfig,
        circuit: AirInventory<SC>,
    ) -> Result<
        VmChipComplex<SC, Self::RecordArena, E::PB, Self::SystemChipInventory>,
        ChipInventoryError,
    > {
        let mut chip_complex =
            VmBuilder::<E>::create_chip_complex(&Rv32ModularCpuBuilder, &config.modular, circuit)?;
        let inventory = &mut chip_complex.inventory;
        VmProverExtension::<E, _, _>::extend_prover(&EccCpuProverExt, &config.ecc, inventory)?;
        Ok(chip_complex)
    }
}
