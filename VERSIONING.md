# OpenVM Versioning

OpenVM follows the naming convention of [semantic versioning](https://semver.org/) (semver) but with different principles:

* `major`: Only changes upon significant proof system updates
* `minor`: Breaking changes where the vkey (MultiStarkVerifyingKey) changes
* `patch`: Backward-compatible changes that preserve vkey compatibility

## Versioning Principles

The core principle of OpenVM versioning is: **"Patch upgrade should be backward compatible"**.

This means if we upgrade from v1.0.0 to v1.0.1, the old verifier of v1.0.0 should be able to verify the new proof generated by v1.0.1. **Crucially, this means the vkey (MultiStarkVerifyingKey) does not change across patch versions.**

## Backward Compatibility Guarantees

The following properties must remain fixed across patch versions (changing these requires a minor version upgrade):

1. **vkey (MultiStarkVerifyingKey struct)**
   - This ensures that a patch-upgraded prover (v1.x.y) can generate proofs that the original verifier (v1.x.0) can verify

2. **Commit structures**
   - app_vm_commit, leaf_vm_commit, internal_vm_commit
   - This includes both the VM itself and the serialization (how the commit is computed)

3. **VmConfig format**

4. **Build toolchain**
   - RISCV custom instructions
   - Transpiler
   - ISA
   - And thus the resulting VmExe

5. **Output of the prove command (CLI+SDK)**
   - The proof format (struct itself and the content)

## Exceptions

Changes that are purely additive without modifying existing objects are exceptions to the above rules and can be included in patch versions. Examples include:

- Adding a new instruction
- Adding a new prove type (STARK)
- Adding a new extension (new StarkVerifyingKey for a new circuit)

## Patch-level Changes

Other changes that aren't security critical and don't modify any of the above components can be included in patch upgrades:

- Prover improvements
- VirtualMachine optimizations
- Executor enhancements
- SDK and CLI updates
- Guest library changes
