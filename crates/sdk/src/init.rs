use std::{fs::File, io::Write, path::Path};

use eyre::Result;
use openvm_algebra_circuit::{Fp2Extension, ModularExtension};
use openvm_ecc_circuit::WeierstrassExtension;

pub const OPENVM_INIT_DEFAULT_FILE_NAME: &str = "openvm_init.rs";

// Reads the vm config and generates a init.rs file that contains a call to moduli_init!,
// complex_init!, sw_init! with the supported moduli and curves.
pub fn generate_init_file(
    manifest_dir: &Path,
    modular_config: &Option<ModularExtension>,
    complex_config: &Option<Fp2Extension>,
    weierstrass_config: &Option<WeierstrassExtension>,
    init_file_name: Option<&str>, // if None, we use "openvm-init.rs"
) -> Result<()> {
    let dest_path =
        Path::new(manifest_dir).join(init_file_name.unwrap_or(OPENVM_INIT_DEFAULT_FILE_NAME));
    let mut f = File::create(&dest_path)?;

    writeln!(
        f,
        r#"// This file is automatically generated by cargo openvm. Do not rename or edit."#,
    )?;

    if let Some(modular_config) = modular_config {
        if let Some(moduli_init) = modular_config.generate_moduli_init() {
            writeln!(f, "{}", moduli_init)?;
        }
    }

    if let Some(complex_config) = complex_config {
        assert!(
            modular_config.is_some(),
            "ModularExtension is required for Fp2Extension"
        );
        let modular_config = modular_config.as_ref().unwrap();
        if let Some(complex_init) = complex_config.generate_complex_init(modular_config) {
            writeln!(f, "{}", complex_init)?;
        }
    }

    if let Some(weierstrass_config) = weierstrass_config {
        if let Some(sw_init) = weierstrass_config.generate_sw_init() {
            writeln!(f, "{}", sw_init)?;
        }
    }

    Ok(())
}
