use std::{fs::File, io::Write, path::Path};

use eyre::Result;
use openvm_algebra_circuit::ModularExtension;

// Reads the vm config and generates a init.rs file that contains a call to moduli_init!,
// complex_init!, sw_init! with the supported moduli and curves.
pub fn generate_init_file(
    manifest_dir: &Path,
    modular_config: &Option<ModularExtension>,
    init_file_name: Option<&str>, // if None, we use "openvm-init.rs"
) -> Result<()> {
    let dest_path = Path::new(manifest_dir).join(init_file_name.unwrap_or("openvm-init.rs"));
    let mut f = File::create(&dest_path)?;

    writeln!(
        f,
        r#"// This file is automatically generated by cargo openvm. Do not rename or edit."#,
    )?;

    write_moduli_init(&mut f, modular_config)?;

    Ok(())
}

fn write_moduli_init(f: &mut File, modular_config: &Option<ModularExtension>) -> Result<()> {
    if let Some(modular) = &modular_config {
        let supported_moduli = modular
            .supported_modulus
            .iter()
            .map(|modulus| format!("\"{}\"", modulus))
            .collect::<Vec<String>>()
            .join(", ");

        writeln!(
            f,
            r#"openvm_algebra_guest::moduli_macros::moduli_init! {{ {supported_moduli} }}"#,
        )
        .map_err(|_| eyre::eyre!("Failed to write moduli_init! to init.rs"))
    } else {
        Ok(())
    }
}

/*
fn write_complex_init(f: &mut File, config: &SdkVmConfig) -> Result<()> {
    if let Some(fp2) = &config.fp2 {
        let supported_moduli = fp2
            .supported_modulus
            .iter()
            .map(|modulus| format!("\"{}\"", modulus))
            .collect::<Vec<String>>()
            .join(", ");

        writeln!(
            f,
            r#"
openvm_algebra_guest::moduli_macros::moduli_init! {{
{supported_moduli}
}}
"#,
        )
        .map_err(|_| eyre::eyre!("Failed to write moduli_init! to init.rs"))
    } else {
        Ok(())
    }
}
*/
