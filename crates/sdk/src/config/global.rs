use bon::Builder;
use openvm_algebra_circuit::{
    Fp2Extension, Fp2ExtensionExecutor, ModularExtension, ModularExtensionExecutor,
};
use openvm_algebra_transpiler::{Fp2TranspilerExtension, ModularTranspilerExtension};
use openvm_bigint_circuit::{Int256, Int256Executor};
use openvm_bigint_transpiler::Int256TranspilerExtension;
use openvm_circuit::{
    arch::{
        instructions::NATIVE_AS, AirInventory, AirInventoryError, ChipInventoryError,
        ExecutorInventory, ExecutorInventoryError, InitFileGenerator, SystemConfig, VmBuilder,
        VmChipComplex, VmCircuitConfig, VmExecutionConfig,
    },
    derive::VmConfig,
    system::SystemExecutor,
};
use openvm_ecc_circuit::{WeierstrassExtension, WeierstrassExtensionExecutor};
use openvm_ecc_transpiler::EccTranspilerExtension;
use openvm_keccak256_circuit::{Keccak256, Keccak256Executor};
use openvm_keccak256_transpiler::Keccak256TranspilerExtension;
use openvm_native_circuit::{CastFExtension, CastFExtensionExecutor, Native, NativeExecutor};
use openvm_native_transpiler::LongFormTranspilerExtension;
use openvm_pairing_circuit::{PairingExtension, PairingExtensionExecutor};
use openvm_pairing_transpiler::PairingTranspilerExtension;
use openvm_rv32im_circuit::{Rv32I, Rv32IExecutor, Rv32Io, Rv32IoExecutor, Rv32M, Rv32MExecutor};
use openvm_rv32im_transpiler::{
    Rv32ITranspilerExtension, Rv32IoTranspilerExtension, Rv32MTranspilerExtension,
};
use openvm_sha256_circuit::{Sha256, Sha256Executor};
use openvm_sha256_transpiler::Sha256TranspilerExtension;
use openvm_stark_backend::{config::StarkGenericConfig, engine::StarkEngine, p3_field::Field};
use openvm_transpiler::transpiler::Transpiler;
use serde::{Deserialize, Serialize};

use crate::F;

#[derive(Builder, Clone, Debug, Serialize, Deserialize)]
#[serde(from = "SdkVmConfigWithDefaultDeser")]
pub struct SdkVmConfig {
    pub system: SdkSystemConfig,
    pub rv32i: Option<UnitStruct>,
    pub io: Option<UnitStruct>,
    pub keccak: Option<UnitStruct>,
    pub sha256: Option<UnitStruct>,
    pub native: Option<UnitStruct>,
    pub castf: Option<UnitStruct>,

    pub rv32m: Option<Rv32M>,
    pub bigint: Option<Int256>,
    pub modular: Option<ModularExtension>,
    pub fp2: Option<Fp2Extension>,
    pub pairing: Option<PairingExtension>,
    pub ecc: Option<WeierstrassExtension>,
}

/// Internal struct to use for the VmConfig derive macro.
/// Can be obtained via [`SdkVmConfig::to_inner`].
#[derive(Clone, Debug, VmConfig, Serialize, Deserialize)]
pub struct SdkVmConfigInner {
    #[config(executor = "SystemExecutor<F>")]
    pub system: SystemConfig,
    #[extension(executor = "Rv32IExecutor")]
    pub rv32i: Option<Rv32I>,
    #[extension(executor = "Rv32IoExecutor")]
    pub io: Option<Rv32Io>,
    #[extension(executor = "Keccak256Executor")]
    pub keccak: Option<Keccak256>,
    #[extension(executor = "Sha256Executor")]
    pub sha256: Option<Sha256>,
    #[extension(executor = "NativeExecutor<F>")]
    pub native: Option<Native>,
    #[extension(executor = "CastFExtensionExecutor")]
    pub castf: Option<CastFExtension>,

    #[extension(executor = "Rv32MExecutor")]
    pub rv32m: Option<Rv32M>,
    #[extension(executor = "Int256Executor")]
    pub bigint: Option<Int256>,
    #[extension(executor = "ModularExtensionExecutor")]
    pub modular: Option<ModularExtension>,
    #[extension(executor = "Fp2ExtensionExecutor")]
    pub fp2: Option<Fp2Extension>,
    #[extension(executor = "PairingExtensionExecutor<F>")]
    pub pairing: Option<PairingExtension>,
    #[extension(executor = "WeierstrassExtensionExecutor")]
    pub ecc: Option<WeierstrassExtension>,
}

// Generated by macro
pub type SdkVmConfigExecutor<F> = SdkVmConfigInnerExecutor<F>;

impl SdkVmConfig {
    pub fn transpiler(&self) -> Transpiler<F> {
        let mut transpiler = Transpiler::default();
        if self.rv32i.is_some() {
            transpiler = transpiler.with_extension(Rv32ITranspilerExtension);
        }
        if self.io.is_some() {
            transpiler = transpiler.with_extension(Rv32IoTranspilerExtension);
        }
        if self.keccak.is_some() {
            transpiler = transpiler.with_extension(Keccak256TranspilerExtension);
        }
        if self.sha256.is_some() {
            transpiler = transpiler.with_extension(Sha256TranspilerExtension);
        }
        if self.native.is_some() {
            transpiler = transpiler.with_extension(LongFormTranspilerExtension);
        }
        if self.rv32m.is_some() {
            transpiler = transpiler.with_extension(Rv32MTranspilerExtension);
        }
        if self.bigint.is_some() {
            transpiler = transpiler.with_extension(Int256TranspilerExtension);
        }
        if self.modular.is_some() {
            transpiler = transpiler.with_extension(ModularTranspilerExtension);
        }
        if self.fp2.is_some() {
            transpiler = transpiler.with_extension(Fp2TranspilerExtension);
        }
        if self.pairing.is_some() {
            transpiler = transpiler.with_extension(PairingTranspilerExtension);
        }
        if self.ecc.is_some() {
            transpiler = transpiler.with_extension(EccTranspilerExtension);
        }
        transpiler
    }
}

impl AsRef<SystemConfig> for SdkVmConfig {
    fn as_ref(&self) -> &SystemConfig {
        &self.system.config
    }
}

impl AsMut<SystemConfig> for SdkVmConfig {
    fn as_mut(&mut self) -> &mut SystemConfig {
        &mut self.system.config
    }
}

impl SdkVmConfig {
    fn to_inner(&self) -> SdkVmConfigInner {
        let system = self.system.config.clone();
        let rv32i = self.rv32i.map(|_| Rv32I);
        let io = self.io.map(|_| Rv32Io);
        let keccak = self.keccak.map(|_| Keccak256);
        let sha256 = self.sha256.map(|_| Sha256);
        let native = self.native.map(|_| Native);
        let castf = self.castf.map(|_| CastFExtension);
        let mut rv32m = self.rv32m;
        let mut bigint = self.bigint;
        if let Some(bigint) = &mut bigint {
            if let Some(rv32m) = &mut rv32m {
                rv32m.range_tuple_checker_sizes[0] =
                    rv32m.range_tuple_checker_sizes[0].max(bigint.range_tuple_checker_sizes[0]);
                rv32m.range_tuple_checker_sizes[1] =
                    rv32m.range_tuple_checker_sizes[1].max(bigint.range_tuple_checker_sizes[1]);
                bigint.range_tuple_checker_sizes = rv32m.range_tuple_checker_sizes;
            }
        }
        let modular = self.modular.clone();
        let fp2 = self.fp2.clone();
        let pairing = self.pairing.clone();
        let ecc = self.ecc.clone();

        SdkVmConfigInner {
            system,
            rv32i,
            io,
            keccak,
            sha256,
            native,
            castf,
            rv32m,
            bigint,
            modular,
            fp2,
            pairing,
            ecc,
        }
    }
}

impl<F: Field> VmExecutionConfig<F> for SdkVmConfig
where
    SdkVmConfigInner: VmExecutionConfig<F>,
{
    type Executor = <SdkVmConfigInner as VmExecutionConfig<F>>::Executor;

    fn create_executors(
        &self,
    ) -> Result<ExecutorInventory<Self::Executor>, ExecutorInventoryError> {
        self.to_inner().create_executors()
    }
}

impl<SC: StarkGenericConfig> VmCircuitConfig<SC> for SdkVmConfig
where
    SdkVmConfigInner: VmCircuitConfig<SC>,
{
    fn create_airs(&self) -> Result<AirInventory<SC>, AirInventoryError> {
        self.to_inner().create_airs()
    }
}

impl<E> VmBuilder<E> for SdkVmConfig
where
    E: StarkEngine,
    SdkVmConfigInner: VmBuilder<E>,
{
    type RecordArena = <SdkVmConfigInner as VmBuilder<E>>::RecordArena;
    type SystemChipInventory = <SdkVmConfigInner as VmBuilder<E>>::SystemChipInventory;

    fn create_chip_complex(
        &self,
        circuit: AirInventory<E::SC>,
    ) -> Result<
        VmChipComplex<E::SC, Self::RecordArena, E::PB, Self::SystemChipInventory>,
        ChipInventoryError,
    > {
        self.to_inner().create_chip_complex(circuit)
    }
}

impl InitFileGenerator for SdkVmConfig {
    fn generate_init_file_contents(&self) -> Option<String> {
        self.to_inner().generate_init_file_contents()
    }
}
impl InitFileGenerator for SdkVmConfigInner {
    fn generate_init_file_contents(&self) -> Option<String> {
        if self.modular.is_some() || self.fp2.is_some() || self.ecc.is_some() {
            let mut contents = String::new();
            contents.push_str(
                "// This file is automatically generated by cargo openvm. Do not rename or edit.\n",
            );

            if let Some(modular_config) = &self.modular {
                contents.push_str(&modular_config.generate_moduli_init());
                contents.push('\n');
            }

            if let Some(fp2_config) = &self.fp2 {
                assert!(
                    self.modular.is_some(),
                    "ModularExtension is required for Fp2Extension"
                );
                let modular_config = self.modular.as_ref().unwrap();
                contents.push_str(&fp2_config.generate_complex_init(modular_config));
                contents.push('\n');
            }

            if let Some(ecc_config) = &self.ecc {
                contents.push_str(&ecc_config.generate_sw_init());
                contents.push('\n');
            }

            Some(contents)
        } else {
            None
        }
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct SdkSystemConfig {
    pub config: SystemConfig,
}

// Default implementation uses no init file
impl InitFileGenerator for SdkSystemConfig {}

impl Default for SdkSystemConfig {
    fn default() -> Self {
        Self {
            config: SystemConfig::default().with_continuations(),
        }
    }
}

impl From<SystemConfig> for SdkSystemConfig {
    fn from(config: SystemConfig) -> Self {
        Self { config }
    }
}

/// A struct that is used to represent a unit struct in the config, used for
/// serialization and deserialization.
#[derive(Clone, Copy, Debug, Default, Serialize, Deserialize)]
pub struct UnitStruct {}

impl From<Rv32I> for UnitStruct {
    fn from(_: Rv32I) -> Self {
        UnitStruct {}
    }
}

impl From<Rv32Io> for UnitStruct {
    fn from(_: Rv32Io) -> Self {
        UnitStruct {}
    }
}

impl From<Keccak256> for UnitStruct {
    fn from(_: Keccak256) -> Self {
        UnitStruct {}
    }
}

impl From<Sha256> for UnitStruct {
    fn from(_: Sha256) -> Self {
        UnitStruct {}
    }
}

impl From<Native> for UnitStruct {
    fn from(_: Native) -> Self {
        UnitStruct {}
    }
}

impl From<CastFExtension> for UnitStruct {
    fn from(_: CastFExtension) -> Self {
        UnitStruct {}
    }
}

#[derive(Deserialize)]
struct SdkVmConfigWithDefaultDeser {
    #[serde(default)]
    pub system: SdkSystemConfig,

    pub rv32i: Option<UnitStruct>,
    pub io: Option<UnitStruct>,
    pub keccak: Option<UnitStruct>,
    pub sha256: Option<UnitStruct>,
    pub native: Option<UnitStruct>,
    pub castf: Option<UnitStruct>,

    pub rv32m: Option<Rv32M>,
    pub bigint: Option<Int256>,
    pub modular: Option<ModularExtension>,
    pub fp2: Option<Fp2Extension>,
    pub pairing: Option<PairingExtension>,
    pub ecc: Option<WeierstrassExtension>,
}

impl From<SdkVmConfigWithDefaultDeser> for SdkVmConfig {
    fn from(config: SdkVmConfigWithDefaultDeser) -> Self {
        let mut system = config.system;
        if config.native.is_none() && config.castf.is_none() {
            // There should be no need to write to native address space if Native extension and
            // CastF extension are not enabled.
            system.config.memory_config.addr_space_sizes[NATIVE_AS as usize] = 0;
        }
        Self {
            system,
            rv32i: config.rv32i,
            io: config.io,
            keccak: config.keccak,
            sha256: config.sha256,
            native: config.native,
            castf: config.castf,
            rv32m: config.rv32m,
            bigint: config.bigint,
            modular: config.modular,
            fp2: config.fp2,
            pairing: config.pairing,
            ecc: config.ecc,
        }
    }
}
