enum Bool ( True, False )

fn merkle_verify(in<[F; 8]> leaf, in<F> length, in<@[Bool]> bits, in<{@[[F; 8]]}> siblings, out<[F; 8]> commit) (
    alloc<[F; 8]> left;
    alloc<[F; 8]> right;
    hash(left, right, def hash_result);
    {match length == 0} (
        True => (
            length = 0;
            set left = [0; 8];
            set right = [0; 8];
            fix commit = leaf;
        )
        False => (
            merkle_verify(leaf, length - 1, bits, siblings, def child);
            def i = length - 1;
            let bit <- bits !! i;
            {let sibling <- siblings !! i};
            match rep bit (
                True => (
                    {set left = sibling};
                    set right = child;
                )
                False => (
                    set left = child;
                    {set right = sibling};
                )
            )
            fix commit = hash_result;
        )
    )
)/*

 columns:
 - 3: state
 - 8: left

 */

inline hash(in<[F; 8]> left, in<[F; 8]> right, out<[F; 8]> result) (
    fix result = [
        left[0] + right[0],
        left[1] * right[1],
        left[2] - right[2],
        left[3],
        right[4],
        115,
        left[6] * left[7],
        right[6] * right[7],
    ];
)

fn main(in<Bool> should_fail) (
    def leaf = [0; 8];
    def a = [1; 8];
    def b = [2; 8];
    def c = [3; 8];

    hash(leaf, a, def x);
    hash(b, x, def y);
    hash(y, c, def root);

    {let siblings0 -> | <[F; 8]>};
    {let siblings1 -> siblings0 | a};
    {let siblings2 -> siblings1 | b};
    {let siblings3 -> siblings2 | c};
    {let siblings = @siblings3};

    def bits0 -> | <Bool>;
    def bits1 -> bits0 | False;
    def bits2 -> bits1 | True;
    def bits3 -> bits2 | False;
    def bits = @bits3;

    match should_fail (
        False => (
            merkle_verify(leaf, 3, bits, siblings, root);
        )
        True => (
            merkle_verify(leaf, 2, bits, siblings, root);
        )
    )
)