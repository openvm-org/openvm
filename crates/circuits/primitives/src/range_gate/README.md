# Range Gate

This chip gets requests to verify that a number is in the range `[0, MAX)`.
In the trace, there is a counter column and a multiplicity column.
The counter column is generated using constraints (gates), as opposed to the [RangeCheckerChip](../range/README.md) which uses preprocessed trace.
The difference is that this chip does not use any preprocessed trace.

The `RangeCheckerGateAir` constrains that the `counter` column is increasing from 0 to `MAX - 1` and also leaves the `mult` column unconstrained.

```rust
    builder
        .when_first_row()
        .assert_eq(local.counter, AB::Expr::ZERO);
    builder
        .when_transition()
        .assert_eq(local.counter + AB::Expr::ONE, next.counter);
    builder.when_last_row().assert_eq(
        local.counter,
        AB::F::from_canonical_u32(self.bus.range_max - 1),
    );
```

Other than that, the interaction constraints work similarly to the [RangeCheckerChip](../range/README.md).

#### 3.1.2 [range_gate](https://github.com/openvm-org/openvm/tree/main/crates/circuits/primitives/src/range_gate)

Range checking without preprocessed columns

This chip implements range checking using a lookup table approach, but with dynamically generated counter values in the trace rather than using preprocessed columns.

**Columns:**
- `counter`: Dynamically generated column containing sequential values from 0 to `range_max-1`
- `mult`: Multiplicity column tracking the number of range checks requested for each value

**Constraints:**

```math
\begin{align}
\texttt{counter}_0 &= 0 & &\hspace{2em} (1)\\
\texttt{counter}_{i+1} - \texttt{counter}_i &= 1 & \forall\ 0 \leq i < H-1 &\hspace{2em} (2)\\
\texttt{counter}_{H-1} &= \texttt{range\_max} - 1 & &\hspace{2em} (3)
\end{align}
```

Constraint (1) ensures the counter starts at 0 on the first row.

Constraint (2) enforces that each subsequent row increments the counter by exactly 1.

Constraint (3) verifies that the last row contains the value `range_max-1`, ensuring the trace has the correct height.

The trace is generated by accumulating the count of range checks requested for each value in the `mult` column, with each row's `counter` value representing the number being checked.

#### 3.1.3 [range_tuple](https://github.com/openvm-org/openvm/tree/main/crates/circuits/primitives/src/range_tuple)

Tuple-based range checking for multiple values simultaneously

This chip efficiently range checks tuples of values using a single interaction when the product of their ranges is relatively small (less than ~2^20). For example, when checking pairs `(x, y)` against their respective bit limits, this approach is more efficient than performing separate range checks.

**Preprocessed Columns:**
- `tuple`: Column containing all possible tuple combinations within the specified ranges

**IO Columns:**
- `mult`: Multiplicity column tracking the number of range checks requested for each tuple

The implementation creates a preprocessed table with all possible value combinations within the specified ranges. The `sizes` parameter in `RangeTupleCheckerBus` defines the maximum value for each dimension.

For a 2-dimensional tuple with `sizes = [3, 2]`, the preprocessed trace contains these 6 combinations in lexicographic order:
```
(0,0)
(1,0)
(2,0)
(0,1)
(1,1)
(2,1)
```

During circuit execution, each row corresponds to a specific tuple from the preprocessed trace, with the `mult` column recording how many times that tuple was requested for range checking.
