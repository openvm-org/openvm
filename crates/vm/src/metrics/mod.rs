use std::{collections::BTreeMap, mem};

use cycle_tracker::CycleTracker;
use metrics::counter;
use openvm_instructions::{
    exe::{FnBound, FnBounds},
    VmOpcode,
};
use openvm_stark_backend::p3_field::PrimeField32;

use crate::{
    arch::{ExecutionSegment, InstructionExecutor, VmConfig},
    system::memory::online::MemoryLogEntry,
};

pub mod cycle_tracker;

#[derive(Clone, Debug, Default)]
pub struct VmMetrics {
    pub cycle_count: usize,
    pub chip_heights: Vec<(String, usize)>,
    /// Maps (dsl_ir, opcode) to number of times opcode was executed
    pub counts: BTreeMap<(Option<String>, String), usize>,
    /// Maps (dsl_ir, opcode, air_name) to number of trace cells generated by opcode
    pub trace_cells: BTreeMap<(Option<String>, String, String), usize>,
    /// Metric collection tools. Only collected when `config.profiling` is true.
    pub cycle_tracker: CycleTracker,
    #[allow(dead_code)]
    pub(crate) fn_bounds: FnBounds,
    /// Cycle span by function if function start/end addresses are available
    #[allow(dead_code)]
    pub(crate) current_fn: FnBound,
    pub(crate) current_trace_cells: Vec<usize>,
    // Maps opcode to number of (instances, reads, writes)
    pub opcode_mem_accesses: BTreeMap<String, (usize, usize, usize)>,
}

impl<F, VC> ExecutionSegment<F, VC>
where
    F: PrimeField32,
    VC: VmConfig<F>,
{
    /// Update metrics that increment per instruction
    #[allow(unused_variables)]
    pub fn update_instruction_metrics(
        &mut self,
        pc: u32,
        old_timestamp: u32,
        opcode: VmOpcode,
        dsl_instr: Option<String>,
    ) {
        self.metrics.cycle_count += 1;

        if self.system_config().profiling {
            let executor = self.chip_complex.inventory.get_executor(opcode).unwrap();
            let opcode_name = executor.get_opcode_name(opcode.as_usize());
            self.metrics.update_trace_cells(
                &self.air_names,
                self.current_trace_cells(),
                opcode_name.clone(),
                dsl_instr,
            );
            self.update_memory_accesses(old_timestamp, opcode_name);

            #[cfg(feature = "function-span")]
            self.metrics.update_current_fn(pc);
        } else {
            let executor = self.chip_complex.inventory.get_executor(opcode).unwrap();
            let opcode_name = executor.get_opcode_name(opcode.as_usize());
            self.update_memory_accesses(old_timestamp, opcode_name);
        }
    }

    fn update_memory_accesses(&mut self, old_timestamp: u32, opcode_name: String) {
        let memory = &self.chip_complex.base.memory_controller;
        let mut new_reads = 0;
        let mut new_writes = 0;

        for entry in memory.get_memory_logs().iter().rev() {
            match entry {
                MemoryLogEntry::Read { timestamp, .. } => {
                    if old_timestamp < *timestamp {
                        break;
                    }
                    new_reads += 1;
                }
                MemoryLogEntry::Write { timestamp, .. } => {
                    if old_timestamp < *timestamp {
                        break;
                    }
                    new_writes += 1;
                }
                _ => {}
            }
        }

        self.metrics
            .opcode_mem_accesses
            .entry(opcode_name)
            .and_modify(|(instances, reads, writes)| {
                *instances += 1;
                *reads += new_reads;
                *writes += new_writes;
            })
            .or_insert((1, new_reads, new_writes));
    }
}

impl VmMetrics {
    fn update_trace_cells(
        &mut self,
        air_names: &[String],
        now_trace_cells: Vec<usize>,
        opcode_name: String,
        dsl_instr: Option<String>,
    ) {
        let key = (dsl_instr, opcode_name);
        self.cycle_tracker.increment_opcode(&key);
        *self.counts.entry(key.clone()).or_insert(0) += 1;

        for (air_name, now_value, prev_value) in
            itertools::izip!(air_names, &now_trace_cells, &self.current_trace_cells)
        {
            if prev_value != now_value {
                let key = (key.0.clone(), key.1.clone(), air_name.to_owned());
                self.cycle_tracker
                    .increment_cells_used(&key, now_value - prev_value);
                *self.trace_cells.entry(key).or_insert(0) += now_value - prev_value;
            }
        }
        self.current_trace_cells = now_trace_cells;
    }

    /// Clear statistics that are local to a segment
    // Important: chip and cycle count metrics should start over for SegmentationStrategy,
    // but we need to carry over the cycle tracker so spans can cross segments
    pub(super) fn clear(&mut self) {
        *self = Self {
            cycle_tracker: mem::take(&mut self.cycle_tracker),
            fn_bounds: mem::take(&mut self.fn_bounds),
            current_fn: mem::take(&mut self.current_fn),
            ..Default::default()
        }
    }

    #[cfg(feature = "function-span")]
    fn update_current_fn(&mut self, pc: u32) {
        if !self.fn_bounds.is_empty() && (pc < self.current_fn.start || pc > self.current_fn.end) {
            self.current_fn = self
                .fn_bounds
                .range(..=pc)
                .next_back()
                .map(|(_, func)| (*func).clone())
                .unwrap();
            if pc == self.current_fn.start {
                self.cycle_tracker.start(self.current_fn.name.clone());
            } else {
                self.cycle_tracker.force_end();
            }
        };
    }

    pub fn emit(&self) {
        for (name, value) in self.chip_heights.iter() {
            let labels = [("chip_name", name.clone())];
            counter!("rows_used", &labels).absolute(*value as u64);
        }

        for ((dsl_ir, opcode), value) in self.counts.iter() {
            let labels = [
                ("dsl_ir", dsl_ir.clone().unwrap_or_else(String::new)),
                ("opcode", opcode.clone()),
            ];
            counter!("frequency", &labels).absolute(*value as u64);
        }

        for ((dsl_ir, opcode, air_name), value) in self.trace_cells.iter() {
            let labels = [
                ("dsl_ir", dsl_ir.clone().unwrap_or_else(String::new)),
                ("opcode", opcode.clone()),
                ("air_name", air_name.clone()),
            ];
            counter!("cells_used", &labels).absolute(*value as u64);
        }

        for (opcode, (instances, reads, writes)) in self.opcode_mem_accesses.iter() {
            let labels = [("opcode", opcode.clone())];
            counter!("instances", &labels).absolute(*instances as u64);
            counter!("reads", &labels).absolute(*reads as u64);
            counter!("writes", &labels).absolute(*writes as u64);
        }
    }
}
