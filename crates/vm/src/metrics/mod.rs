use std::{collections::BTreeMap, mem};

use backtrace::Backtrace;
use cycle_tracker::CycleTracker;
use itertools::Itertools;
use metrics::counter;
use openvm_instructions::{
    exe::{FnBound, FnBounds},
    program::ProgramDebugInfo,
};
use openvm_stark_backend::prover::{hal::ProverBackend, types::DeviceMultiStarkProvingKey};

use crate::{
    arch::{
        execution_mode::tracegen::TracegenCtx, Arena, DenseRecordArena, InstructionExecutor,
        VmSegmentState,
    },
    system::{
        memory::{adapter::AccessAdapterInventory, online::TracingMemory},
        program::PcEntry,
    },
};

pub mod cycle_tracker;

#[derive(Clone, Debug, Default)]
pub struct VmMetrics {
    // Static info
    pub air_names: Vec<String>,
    pub debug_infos: ProgramDebugInfo,
    #[cfg(feature = "perf-metrics")]
    pub(crate) num_sys_airs: usize,
    #[cfg(feature = "perf-metrics")]
    pub(crate) access_adapter_offset: usize,
    pub(crate) main_widths: Vec<usize>,
    pub(crate) total_widths: Vec<usize>,

    // Dynamic stats
    /// Maps (dsl_ir, opcode) to number of times opcode was executed
    pub counts: BTreeMap<(Option<String>, String), usize>,
    /// Maps (dsl_ir, opcode, air_name) to number of trace cells generated by opcode
    pub trace_cells: BTreeMap<(Option<String>, String, String), usize>,
    /// Metric collection tools. Only collected when "perf-metrics" feature is enabled.
    pub cycle_tracker: CycleTracker,

    pub(crate) current_trace_cells: Vec<usize>,

    /// Backtrace for guest debug panic display
    pub prev_backtrace: Option<Backtrace>,
    #[allow(dead_code)]
    pub(crate) fn_bounds: FnBounds,
    /// Cycle span by function if function start/end addresses are available
    #[allow(dead_code)]
    pub(crate) current_fn: FnBound,
}

/// We assume this will be called after execute_instruction, so less error-handling is needed.
#[allow(unused_variables)]
#[inline(always)]
pub fn update_instruction_metrics<F, RA, Executor>(
    state: &mut VmSegmentState<F, TracingMemory, TracegenCtx<RA>>,
    executor: &mut Executor,
    pc_entry: &PcEntry<F>,
) where
    F: Clone + Send + Sync,
    RA: Arena,
    Executor: InstructionExecutor<F, RA>,
{
    #[cfg(any(debug_assertions, feature = "perf-metrics"))]
    state.metrics.update_backtrace(state.pc);

    #[cfg(feature = "perf-metrics")]
    {
        use std::iter::zip;

        let pc = state.pc;
        let opcode = pc_entry.insn.opcode;
        let opcode_name = executor.get_opcode_name(opcode.as_usize());
        let metrics = &mut state.ctx.metrics;
        let debug_info = metrics.debug_infos.get(pc);
        let dsl_instr = debug_info.as_ref().map(|info| info.dsl_instruction.clone());
        let now_trace_heights = get_dyn_trace_heights_from_arenas::<F, _>(
            metrics.num_sys_airs,
            metrics.access_adapter_offset,
            &state.memory.access_adapter_records,
            &state.ctx.arenas,
        );
        let mut now_trace_cells = now_trace_heights;
        for (main_width, cell_count) in zip(&metrics.main_widths, &mut now_trace_cells) {
            *cell_count *= main_width;
        }
        metrics.update_trace_cells(now_trace_cells, opcode_name, dsl_instr);

        metrics.update_current_fn(state.pc);
    }
}

/// Assumed that `record_arenas` has length equal to number of AIRs.
///
/// Best effort calculation of the used trace heights per chip without padding to powers of
/// two. This is best effort because some periphery chips may not have record arenas
/// to instrument.
///
/// Does not include constant trace heights or the used program trace height.
pub(crate) fn get_dyn_trace_heights_from_arenas<F, RA>(
    num_sys_airs: usize,
    access_adapter_offset: usize,
    access_adapter_records: &DenseRecordArena,
    record_arenas: &[RA],
) -> Vec<usize>
where
    F: Clone + Send + Sync,
    RA: Arena,
{
    // First, get used heights from record arenas
    let mut heights: Vec<usize> = record_arenas
        .iter()
        .map(|arena| arena.current_trace_height())
        .collect();
    // Memory is special case, so extract the memory AIR's trace heights from the special
    // arena
    AccessAdapterInventory::<F>::compute_heights_from_arena(
        access_adapter_records,
        &mut heights[access_adapter_offset..num_sys_airs],
    );

    heights
}

impl VmMetrics {
    pub fn set_pk_info<PB: ProverBackend>(&mut self, pk: &DeviceMultiStarkProvingKey<PB>) {
        let (air_names, main_widths, total_widths): (Vec<_>, Vec<_>, Vec<_>) = pk
            .per_air
            .iter()
            .map(|pk| {
                let air_names = pk.air_name.clone();
                let width = &pk.vk.params.width;
                let main_width = width.main_width();
                let total_width = width.total_width(PB::CHALLENGE_EXT_DEGREE as usize);
                (air_names, main_width, total_width)
            })
            .multiunzip();
        self.air_names = air_names;
        self.main_widths = main_widths;
        self.total_widths = total_widths;
    }

    pub fn update_trace_cells(
        &mut self,
        now_trace_cells: Vec<usize>,
        opcode_name: String,
        dsl_instr: Option<String>,
    ) {
        let key = (dsl_instr, opcode_name);
        self.cycle_tracker.increment_opcode(&key);
        *self.counts.entry(key.clone()).or_insert(0) += 1;

        for (air_name, now_value, prev_value) in
            itertools::izip!(&self.air_names, &now_trace_cells, &self.current_trace_cells)
        {
            if prev_value != now_value {
                let key = (key.0.clone(), key.1.clone(), air_name.to_owned());
                self.cycle_tracker
                    .increment_cells_used(&key, now_value - prev_value);
                *self.trace_cells.entry(key).or_insert(0) += now_value - prev_value;
            }
        }
        self.current_trace_cells = now_trace_cells;
    }

    /// Take the cycle tracker and fn bounds information for use in
    /// next segment. Leave the rest of the metrics for recording purposes.
    pub fn partial_take(&mut self) -> Self {
        Self {
            cycle_tracker: mem::take(&mut self.cycle_tracker),
            fn_bounds: mem::take(&mut self.fn_bounds),
            current_fn: mem::take(&mut self.current_fn),
            ..Default::default()
        }
    }

    /// Clear statistics that are local to a segment
    // Important: chip and cycle count metrics should start over for SegmentationStrategy,
    // but we need to carry over the cycle tracker so spans can cross segments
    pub fn clear(&mut self) {
        *self = self.partial_take();
    }

    #[cfg(any(debug_assertions, feature = "perf-metrics"))]
    pub fn update_backtrace(&mut self, pc: u32) {
        if let Some(info) = self.debug_infos.get(pc) {
            if let Some(trace) = &info.trace {
                self.prev_backtrace = Some(trace.clone());
            }
        }
    }

    #[cfg(feature = "perf-metrics")]
    pub(super) fn update_current_fn(&mut self, pc: u32) {
        if self.fn_bounds.is_empty() {
            return;
        }
        if pc < self.current_fn.start || pc > self.current_fn.end {
            self.current_fn = self
                .fn_bounds
                .range(..=pc)
                .next_back()
                .map(|(_, func)| (*func).clone())
                .unwrap();
            if pc == self.current_fn.start {
                self.cycle_tracker.start(self.current_fn.name.clone());
            } else {
                while let Some(name) = self.cycle_tracker.top() {
                    if name == &self.current_fn.name {
                        break;
                    }
                    self.cycle_tracker.force_end();
                }
            }
        };
    }

    pub fn emit(&self) {
        for ((dsl_ir, opcode), value) in self.counts.iter() {
            let labels = [
                ("dsl_ir", dsl_ir.clone().unwrap_or_else(String::new)),
                ("opcode", opcode.clone()),
            ];
            counter!("frequency", &labels).absolute(*value as u64);
        }

        for ((dsl_ir, opcode, air_name), value) in self.trace_cells.iter() {
            let labels = [
                ("dsl_ir", dsl_ir.clone().unwrap_or_else(String::new)),
                ("opcode", opcode.clone()),
                ("air_name", air_name.clone()),
            ];
            counter!("cells_used", &labels).absolute(*value as u64);
        }
    }
}
