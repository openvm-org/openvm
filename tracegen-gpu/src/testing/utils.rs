use core::fmt::Debug;
use std::sync::Arc;

use openvm_stark_backend::{
    p3_matrix::{dense::RowMajorMatrix, Matrix},
    prover::hal::MatrixDimensions,
    Chip,
};
use stark_backend_gpu::{
    base::DeviceMatrix,
    cuda::copy::MemCopyD2H,
    data_transporter::transport_device_matrix_to_host,
    prelude::{F, SC},
};

// Asserts that the entire trace generated by chip is equal to gpu_matrix, i.e.
// that the GPU-generated trace is the same as the CPU-generated one
pub fn test_chip_whole_trace_output<C: Chip<SC>>(chip: C, gpu_matrix: &DeviceMatrix<F>) {
    let air_proof_input = chip.generate_air_proof_input();
    let cpu_matrix = Arc::new(air_proof_input.raw.common_main.unwrap());
    assert_eq_cpu_and_gpu_matrix(cpu_matrix, gpu_matrix);
}

// Asserts that two DeviceMatrix are equal
pub fn assert_eq_gpu_matrix<T: PartialEq + Debug>(a: &DeviceMatrix<T>, b: &DeviceMatrix<T>) {
    assert_eq!(a.height(), b.height());
    assert_eq!(a.width(), b.width());
    assert_eq!(a.buffer().len(), b.buffer().len());
    let a_vec = a.buffer().to_host().unwrap();
    let b_vec = b.buffer().to_host().unwrap();
    for i in 0..a.buffer().len() {
        assert_eq!(a_vec[i], b_vec[i], "Mismatch at index {}", i);
    }
}

// Asserts that a RowMajorMatrix and a DeviceMatrix (a column-major matrix)
// are equal
pub fn assert_eq_cpu_and_gpu_matrix<T: Clone + Send + Sync + PartialEq + Debug>(
    cpu: Arc<RowMajorMatrix<T>>,
    gpu: &DeviceMatrix<T>,
) {
    assert_eq!(gpu.width(), cpu.width());
    assert_eq!(gpu.height(), cpu.height());
    let gpu = transport_device_matrix_to_host(gpu);
    for r in 0..cpu.height() {
        for c in 0..cpu.width() {
            assert_eq!(
                gpu.get(r, c),
                cpu.get(r, c),
                "Mismatch at row {} column {}",
                r,
                c
            );
        }
    }
}

// Utility function to print out a DeviceMatrix as a RowMajorMatrix for easy
// comparison during debugging
pub fn print_gpu_matrix_as_row_major_matrix<T: Clone + Send + Sync + Debug>(
    gpu_matrix: &DeviceMatrix<T>,
) {
    println!("{:?}", transport_device_matrix_to_host(gpu_matrix));
}
