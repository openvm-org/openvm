use core::fmt::Debug;
use std::sync::Arc;

use cuda_utils::copy::MemCopyD2H;
use openvm_stark_backend::{p3_matrix::dense::RowMajorMatrix, prover::hal::MatrixDimensions, Chip};
use stark_backend_gpu::{
    base::DeviceMatrix,
    prelude::{F, SC},
};

// Asserts that the entire trace generated by chip is equal to gpu_matrix, i.e.
// that the GPU-generated trace is the same as the CPU-generated one
pub fn test_chip_whole_trace_output<C: Chip<SC>>(chip: C, gpu_matrix: &DeviceMatrix<F>) {
    let air_proof_input = chip.generate_air_proof_input();
    let cpu_matrix = Arc::new(air_proof_input.raw.common_main.unwrap());
    assert_eq_cpu_and_gpu_matrix(cpu_matrix, gpu_matrix);
}

// Asserts that two DeviceMatrix are equal
pub fn assert_eq_gpu_matrix<T: PartialEq + Debug>(a: &DeviceMatrix<T>, b: &DeviceMatrix<T>) {
    assert_eq!(a.height(), b.height());
    assert_eq!(a.width(), b.width());
    assert_eq!(a.buffer().len(), b.buffer().len());
    let a_vec = a.buffer().to_host().unwrap();
    let b_vec = b.buffer().to_host().unwrap();
    for i in 0..a.buffer().len() {
        assert_eq!(a_vec[i], b_vec[i], "Mismatch at index {}", i);
    }
}

// Asserts that a RowMajorMatrix and a DeviceMatrix (a column-major matrix)
// are equal
pub fn assert_eq_cpu_and_gpu_matrix<T: Clone + Send + Sync + PartialEq + Debug>(
    cpu: Arc<RowMajorMatrix<T>>,
    gpu: &DeviceMatrix<T>,
) {
    let gpu_vec = gpu.to_host().unwrap();
    let cpu_vec = &cpu.values;
    assert_eq!(gpu.width(), cpu.width());
    assert_eq!(gpu.height(), cpu.height());
    assert_eq!(gpu_vec.len(), cpu_vec.len());
    for c in 0..gpu.width() {
        for r in 0..gpu.height() {
            assert_eq!(gpu_vec[c * gpu.height() + r], cpu_vec[r * cpu.width() + c]);
        }
    }
}
